{
    "skillsData": [
      {
        "id": "dynamicJSX",
        "title": "How to build medium-like blog posts with dynamic rendering",
        "blurb": "This skill demonstrates dynamically generating content from data to JSX in React and Next.js.",
        "tags": [
          "React",
          "Next.js",
          "dynamic rendering"
        ],
        "link": "/skills/dynamicJSX",
        "linkText": "Explore making Medium",
        "paragraphs": [
          "### Dynamically Generating Content from Data to JSX",
          "When building applications with React and Next.js, you often need to render content dynamically based on data. This involves mapping data structures to JSX components, enabling a flexible and scalable approach to rendering user interfaces.",
          "### Example Data Structure",
          "Consider the following `skillsData` object:",
          "```js\nconst skillsData = [\n  {\n    id: \"test-skill\",\n    title: \"Test Skill\",\n    blurb: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio.\",\n    tags: [\"Tag1\", \"Tag2\", \"Tag3\"],\n    link: \"/skills/test-skill\",\n    linkText: \"Press for link\",\n    paragraphs: [\n      \"First paragraph of the test skill.\",\n      \"Second paragraph of the test skill.\",\n      \"Third paragraph of the test skill.\"\n    ]\n  },\n  // More skills can be added here\n];\n```",
          "### Rendering Data in JSX",
          "To dynamically generate JSX from this data, you can map over the `skillsData` array and render each item using a component like `FullStretchCard`.",
          "### Example Component (`skills.js`)",
          "```js\nimport FullStretchCard from \"@/components/utility/button/fullStretchCard\";\nimport skillsData from \"@/data/skillsData\";\n\nexport default function Skills() {\n  return (\n    \u003C\u003E\n      {skillsData.map((skill, index) =\u003E (\n        \u003CFullStretchCard\n          key={index}\n          title={skill.title}\n          blurb={skill.blurb}\n          tags={skill.tags.join(', ')}\n          link={skill.link}\n          linkText={skill.linkText}\n        /\u003E\n      ))}\n    \u003C/\u003E\n  );\n}\n```",
          "In this example, `skillsData.map` iterates over each skill, passing the relevant properties to `FullStretchCard` components.",
          "### Handling Dynamic Routes with `useRouter`",
          "Next.js provides the `useRouter` hook to handle dynamic routes. This is particularly useful for pages that display content based on URL parameters.",
          "### Example Component (`[individualSkill].js`)",
          "```js\nimport { useRouter } from \"next/router\";\nimport Link from \"next/link\";\nimport skillsData from \"@/data/skillsData\";\n\nexport default function IndividualSkill() {\n  const router = useRouter();\n  const { individualSkill } = router.query;\n  const skill = skillsData.find(skill =\u003E skill.id === individualSkill);\n  \n  if (!skill) {\n    return \u003Cdiv\u003ELoading...\u003C/div\u003E;\n  }\n  \n  return (\n    \u003Cdiv className=\"individualSkillContainer\"\u003E\n      \u003Cdiv className=\"individualSkillInner\"\u003E\n        \u003Ch2 className=\"individualSkillTitle\"\u003E{skill.title}\u003C/h2\u003E\n        {skill.paragraphs.map((paragraph, index) =\u003E (\n          \u003Cdiv key={index} className=\"individualSkillParagraph\"\u003E\n            {paragraph.startsWith(\"```\") ? (\n              \u003Cpre\u003E\n                \u003Ccode\u003E{paragraph.replace(/```/g, \"\")}\u003C/code\u003E\n              \u003C/pre\u003E\n            ) : (\n              paragraph.startsWith(\"###\") ?\n                \u003Cb\u003E{paragraph.replace(/###/g, \"\")}\u003C/b\u003E :\n                \u003Cp\u003E{paragraph}\u003C/p\u003E\n            )}\n          \u003C/div\u003E\n        ))}\n        \u003Cdiv className=\"individualSkillTags\"\u003E\n          {skill.tags.map((tag, index) =\u003E (\n            \u003Cspan key={index} className=\"individualSkillTag\"\u003E{tag}\u003C/span\u003E\n          ))}\n        \u003C/div\u003E\n        \u003CLink href=\"/skills\"\u003E\n          \u003Cbutton className=\"backButton\"\u003EBack to Skills\u003C/button\u003E\n        \u003C/Link\u003E\n      \u003C/div\u003E\n    \u003C/div\u003E\n  );\n}\n```",
          "### Understanding `useRouter`",
          "- **useRouter Hook**: The `useRouter` hook from Next.js allows you to access the router object, which contains information about the current route.",
          "- **router.query**: This object holds the dynamic route parameters. In this case, `individualSkill` is extracted from `router.query`.",
          "### Breaking Down the Ternary Statement",
          "The ternary statement in the component above conditionally renders different elements based on the content of the paragraph.",
          "```js\n{paragraph.startsWith(\"```\") ? (\n  \u003Cpre\u003E\n    \u003Ccode\u003E{paragraph.replace(/```/g, \"\")}\u003C/code\u003E\n  \u003C/pre\u003E\n) : (\n  paragraph.startsWith(\"###\") ?\n    \u003Cb\u003E{paragraph.replace(/###/g, \"\")}\u003C/b\u003E :\n    \u003Cp\u003E{paragraph}\u003C/p\u003E\n)}\n```",
          "- **Condition Check**: `paragraph.startsWith(\"```\")`\n  - If the paragraph starts with \"``\"\", it indicates a code block.\n  - The code inside the block is wrapped in `\u003Cpre\u003E` and `\u003Ccode\u003E` tags after removing the \"``\"\" markers.",
          "- **Nested Condition Check**: `paragraph.startsWith(\"###\")`\n  - If the paragraph starts with \"###\", it indicates a heading.\n  - The heading text is wrapped in `\u003Cb\u003E` tags after removing the \"###\" markers.",
          "- **Default Case**: `\u003Cp\u003E{paragraph}\u003C/p\u003E`\n  - If neither condition is met, the paragraph is treated as regular text and wrapped in `\u003Cp\u003E` tags.",
          "Utilizing ternaries and the startsWith method you can add many different start conditions to your paragraphs. You could even add photo paths by designating a start condition for a photo src.",
          "&&&/jake fancy.jpg",
          "### Conclusion",
          "By using a centralized data file and dynamically rendering content with React and Next.js, you can create flexible and scalable applications. The `useRouter` hook facilitates dynamic routing, allowing you to build pages that respond to URL parameters. The ternary operator in JSX enables conditional rendering, making your components more dynamic and responsive to different types of content."
        ]
      },
      {
        "id": "zoom-application",
        "title": "How to Build a Zoom Application with PeerJS, Socket.IO, and EJS",
        "blurb": "Learn how to set up a video chat application similar to Zoom using PeerJS, Socket.IO, and EJS.",
        "tags": [
          "WebRTC",
          "PeerJS",
          "Socket.IO",
          "EJS"
        ],
        "link": "/skills/zoom-application",
        "linkText": "Explore making zoom",
        "paragraphs": [
          "Let's explore the different possibilities of connecting with other people on the internet. In all of our examples we will use client A as reference to sending information to client B. When you first learn about web development you likely learned about HTTP requests such as fetch or axios. HTTP requests are great as they validate the information that is coming into and out of your server. However, without refreshing client B won't see what client A posted. There have been work around for this such as long polling(Sending a get request to the server and the server holds that request until an update happens). Long Polling is great for handling updates, but its slow because client A has to send a message to the server. The server has to process the message, check it against a database, route the message to the correct user and has to ensure that Client B has sent a GET request to the server. This is not great for sending 30-60 frames of video per second to a user. Socket.io is an upgrade in speed. Socket.io relies on TCP connections. A TCP connection is able to cut out the database and we can establish a connection directly from client A to server to client B. However, we are essentially doubling the length it takes to send a message to a user so this still is not viable for video connection. This is where PeerJS is a library that works with socket.io(to establish an initial connection) that is PeerJS comes in handy. PeerJS relies on UDP which allows client A to connect directly with client B after an initial handshake. This is a reliable way to send information from client A to client B at 30-60 frames per second. PeerJS gives you the option to make live video feeds, transfer gaming data back and forth, or make collaborative design software. The Possibilities are extensive. In this tutorial, we will walk through the steps required to build a video chat application similar to Zoom using PeerJS, Socket.IO, and EJS.",
          "### Setting Up the Project",
          "First, create a new Node.js project and install the necessary dependencies.",
          "```bash\nmkdir zoom-app\ncd zoom-app\nnpm init -y\nnpm install express ejs socket.io peerjs\n```",
          "### Setting Up the Server",
          "Create a file named `server.js` and set up an Express server with Socket.IO and PeerJS.",
          "```js\nconst express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\nconst { ExpressPeerServer } = require('peer');\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIO(server);\nconst peerServer = ExpressPeerServer(server, { debug: true });\napp.set('view engine', 'ejs');\napp.use('/peerjs', peerServer);\napp.use(express.static('public'));\napp.get('/', (req, res) =\u003E {\n  res.render('index');\n});\napp.get('/:room', (req, res) =\u003E {\n  res.render('room', { roomId: req.params.room });\n});\nio.on('connection', (socket) =\u003E {\n  socket.on('join-room', (roomId, userId) =\u003E {\n    socket.join(roomId);\n    socket.to(roomId).broadcast.emit('user-connected', userId);\n  });\n});\nserver.listen(3000, () =\u003E {\n  console.log('Server is running on port 3000');\n});\n```",
          "### Creating the Views",
          "Create an `index.ejs` file for the home page and a `room.ejs` file for the video chat room.",
          "```html\n\u003C!-- views/room.ejs --\u003E\n\u003C!DOCTYPE html\u003E\n\u003Chtml lang=\"en\"\u003E\n\u003Chead\u003E\n  \u003Cmeta charset=\"UTF-8\"\u003E\n  \u003Cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003E\n  \u003Ctitle\u003ERoom \u003C%= roomId %\u003E\u003C/title\u003E\n  \u003Cscript src=\"/socket.io/socket.io.js\"\u003E\u003C/script\u003E\n  \u003Cscript src=\"https://unpkg.com/peerjs\"\u003E\u003C/script\u003E\n  \u003Cscript\u003E\n    const roomId = '\u003C%= roomId %\u003E';\n  \u003C/script\u003E\n  \u003Cscript src=\"/js/room.js\"\u003E\u003C/script\u003E\n\u003C/head\u003E\n\u003Cbody\u003E\n  \u003Ch1\u003ERoom \u003C%= roomId %\u003E\u003C/h1\u003E\n  \u003Cvideo id=\"my-video\" autoplay muted\u003E\u003C/video\u003E\n  \u003Cdiv id=\"video-grid\"\u003E\u003C/div\u003E\n\u003C/body\u003E\n\u003C/html\u003E\n```",
          "### Setting Up the Client",
          "Create a `public/js/room.js` file to handle the client-side logic for connecting to the room and streaming video.",
          "```js\nconst socket = io('/');\nconst videoGrid = document.getElementById('video-grid');\nconst myVideo = document.createElement('video');\nmyVideo.muted = true;\nnavigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream =\u003E {\n  addVideoStream(myVideo, stream);\n  const peer = new Peer(undefined, { path: '/peerjs', host: '/', port: '3000' });\n  peer.on('open', id =\u003E {\n    socket.emit('join-room', roomId, id);\n  });\n  peer.on('call', call =\u003E {\n    call.answer(stream);\n    const video = document.createElement('video');\n    call.on('stream', userVideoStream =\u003E {\n      addVideoStream(video, userVideoStream);\n    });\n  });\n  socket.on('user-connected', userId =\u003E {\n    connectToNewUser(userId, stream);\n  });\n  function connectToNewUser(userId, stream) {\n    const call = peer.call(userId, stream);\n    const video = document.createElement('video');\n    call.on('stream', userVideoStream =\u003E {\n      addVideoStream(video, userVideoStream);\n    });\n  }\n  function addVideoStream(video, stream) {\n    video.srcObject = stream;\n    video.addEventListener('loadedmetadata', () =\u003E {\n      video.play();\n    });\n    videoGrid.append(video);\n  }\n});\n```",
          "### Conclusion",
          "With the above steps, you have set up a basic video chat application using PeerJS, Socket.IO, and EJS. You can further customize and expand this application by adding more features such as chat, screen sharing, and more."
        ]
      },
      {
        "id": "restful-express",
        "title": "Building Scalable APIs with RESTful Express",
        "blurb": "Learn how to use RESTful conventions in Express.js to create scalable and maintainable APIs.",
        "tags": [
          "Express.js",
          "RESTful API",
          "JavaScript"
        ],
        "link": "/skills/restful-express",
        "linkText": "Learn to Build RESTful APIs with Express",
        "paragraphs": [
          "### Introduction to RESTful Conventions in Express",
          "Not adhering to RESTful conventions can lead to poorly structured and hard-to-maintain APIs. Using RESTful conventions in Express.js helps create clear, predictable, and scalable endpoints.",
          "### Understanding Routes, app.js, and Controllers",
          "In an Express application, **routes** define the various endpoints for your API. The **app.js** file sets up the application and includes middleware and route definitions. **Controllers** handle the business logic for each route, keeping your code organized and maintainable.",
          "### Example Directory Structure",
          "Here’s an example of a directory structure for an Express application:",
          "```\nmy-express-app/\n|-- app.js\n|--config\n|   |-- psqlSetup.js\n|-- routes/\n|   |-- users.js\n|-- controllers/\n|   |-- userController.js\n|-- utils/\n|   |-- authenticate.js\n|-- models/\n|   |-- user.js\n```",
          "### Using app.use() for Route Management",
          "In Express, you can use `app.use()` to include your routes, which helps in organizing your code and improving scalability. For example:",
          "```routes/users.js\nconst express = require('express');\nconst app = express();\nconst userRoutes = require('./routes/users');\napp.use('/users', userRoutes);\napp.listen(4000,()=>{console.log('server listening on port 4000')})```",
          "### Benefits of Route Scalability",
          "By creating different routes, you can handle various endpoints efficiently. This separation of concerns allows for better maintenance and scalability of your application.",
          "### Using Query Strings for Data Filtering",
          "You can use query strings in your routes to filter data. For instance, to filter users by specific criteria, such as their name starting with a specific letter:",
          "```js\n//config/psqlSetup.js\nconst { Client } = require('pg');\nrequire('dotenv').config();\n\nconst client = new Client({\n  user: 'postgres',\n  host: '127.0.0.1',\n  password: process.env.DATABASE_PASSWORD,\n  port: 5432\n});\n\nclient.connect()\n  .then(() => console.log('connected to postgres'))\n  .catch(err => console.error('connection error', err.stack));\n\nmodule.exports = client;\n\n\n//controllers/userController.js\nconst express = require('express');\nconst router = express.Router();\nconst client = require('../config/psqlSetup');\n\nrouter.get('/users', async (req, res) => {\n  const { name } = req.query;\n\n  let query = 'SELECT * FROM users';\n  const queryParams = [];\n\n  if (name) {\n    queryParams.push(`${name}%`);\n    query += ` WHERE name LIKE $${queryParams.length}`;\n  }\n\n  try {\n    const result = await client.query(query, queryParams);\n    const users = result.rows;\n    res.send(users);\n  } catch (err) {\n    res.status(500).send('Error retrieving users')\nfinally{\n if(client){client.close()}\n}\n})\n\nmodule.exports = router;\n```",
          "In this example, we use query parameters to filter users by their name. The `req.query` object contains the query parameters sent in the request URL. By using SQL's `LIKE` operator, we can find users whose names start with a specific letter, such as 'a'.",
          "### Middleware for Authentication",
          "Middleware functions in Express can be used to handle various tasks such as authentication. A common middleware I use is `utils.authenticate` which validates the user:",
          "```js\nconst utils = require('./utils');\napp.use('/private', utils.authenticate, (req, res) => {\n  res.send('Authenticated route');\n});\n```",
          "### Storing Data with PostgreSQL",
          "Using PostgreSQL with a `pg` client, you can store user data efficiently. For example, to store a new user:",
          "```js\nconst { Client } = require('pg');\nconst client = new Client();\nclient.connect();\napp.post('/users', (req, res) => {\n  const { name, age } = req.body;\n  client.query('INSERT INTO users (name, age) VALUES ($1, $2)', [name, age], (err) => {\n    if (err) throw err;\n    res.send('User added');\n  });\n});\n```",
          "### Adding More Routes",
          "With a structured approach, you can easily add more routes such as DELETE and POST without cluttering your code:",
          "```js\napp.delete('/users/:id', (req, res) => {\n  const userId = req.params.id;\n  client.query('DELETE FROM users WHERE id = $1', [userId], (err) => {\n    if (err) throw err;\n    res.send('User deleted');\n  });\n});\n```",
          "### Conclusion",
          "Following RESTful conventions in Express.js and leveraging features like middleware, query strings, and PostgreSQL integration can significantly enhance the scalability and maintainability of your APIs. This structured approach ensures your application can grow and adapt to new requirements efficiently."
        ]
      }
    ]
  }